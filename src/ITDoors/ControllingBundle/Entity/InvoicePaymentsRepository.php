<?php

namespace ITDoors\ControllingBundle\Entity;

use Doctrine\ORM\EntityRepository;

/**
 * InvoicePaymentsRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class InvoicePaymentsRepository extends EntityRepository
{
    /**
     * @param integer $customerId
     * @param array   $filters
     *
     * @return mixed[]
     */
    public function getForCustomer($customerId, $filters)
    {
        $sql = $this->createQueryBuilder('ip')
            ->select('ip.date')
            ->addSelect('ip.summa as summaPay')
            ->addSelect('i.date invoiceDate')
            ->addSelect('i.delayDate')
            ->innerJoin('ip.invoice', 'i')
            ->where('i.customerId = :customerId')
            ->andWhere('i.delayDate < ip.date')
            ->andWhere('i.dateFact is NULL')
            ->setParameter('customerId', $customerId);
        if (sizeof($filters)) {
            foreach ($filters as $key => $value) {
                if (!$value) {
                    continue;
                }
                switch ($key) {
                    case 'daterange':
                        $dateArr = explode('-', $value);
//                        $dateStart = new \DateTime(str_replace('.', '-', $dateArr[0]));
                        $dateStop = new \DateTime('23:59:59 '.str_replace('.', '-', $dateArr[1]));

                        $sql->andWhere('i.date <= :datestop')
//                            ->setParameter(':datestart', $dateStart)
                            ->setParameter(':datestop', $dateStop);
                        break;
                }
            }
        }

        return $sql
                ->orderBy('ip.date')
                ->getQuery()
                ->getResult();
    }
    /**
     * @param integer $customerId
     * @param array   $filters
     *
     * @return mixed[]
     */
    public function getForAnaliticAll($customerId, $filters)
    {
        $sql = $this->createQueryBuilder('ip')
            ->select('ip.date')
            ->addSelect('ip.summa as summaPay')
            ->addSelect('i.date invoiceDate')
            ->addSelect('i.delayDate')
            ->innerJoin('ip.invoice', 'i')
            ->where('i.customerId = :customerId')
            ->setParameter('customerId', $customerId);
        if (sizeof($filters)) {
            foreach ($filters as $key => $value) {
                if (!$value) {
                    continue;
                }
                switch ($key) {
                    case 'daterange':
                        $dateArr = explode('-', $value);
//                        $dateStart = new \DateTime(str_replace('.', '-', $dateArr[0]));
                        $dateStop = new \DateTime('23:59:59 '.str_replace('.', '-', $dateArr[1]));

                        $sql->andWhere('i.date <= :datestop')
//                            ->setParameter(':datestart', $dateStart)
                            ->setParameter(':datestop', $dateStop);
                        break;
                }
            }
        }

        return $sql
                ->orderBy('ip.date')
                ->getQuery()
                ->getResult();
    }
    /**
     * getSum
     * 
     * @param integer $invoiceId
     * 
     * @return integer
     */
    public function getSum ($invoiceId)
    {

        return $this->createQueryBuilder('p')
            ->select('SUM(p.summa)')
            ->where('p.invoiceId = :invoiceId')
            ->setParameter(':invoiceId', $invoiceId)
            ->getQuery()->getOneOrNullResult();
    }

    /**
     * dateLastPay
     * 
     * @param integer $invoiceId
     * 
     * @return mixed|null
     */
    public function dateLastPay ($invoiceId)
    {

        return $this->createQueryBuilder('p')
            ->select('p.date')
            ->where('p.invoiceId = :invoiceId')
            ->setParameter(':invoiceId', $invoiceId)
            ->orderBy('p.date', 'DESC')
            ->getQuery()->getResult();
    }
}
